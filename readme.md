
<body class="c19 c37"><div><p class="c6 c29 c9"><span></span></p></div><p class="c6 c22 c32 title"><a id="h.j8tnti9wmwrn" name="h.j8tnti9wmwrn"></a><span>Report of Compiler Principle</span></p><p class="c6 c22 c32 subtitle"><a id="h.5eokux7ug7oe" name="h.5eokux7ug7oe"></a><span>Project 2</span></p><p class="c6 c29"><span class="c3"><a class="c11" href="mailto:jiady@sjtu.edu.cn">Dongyu Jia (5120309607)</a></span></p><p class="c6 c29"><span>01/20/2016 </span></p><p class="c6 c9"><span></span></p><p class="c6 c17"><span class="c3"><a class="c11" href="#h.shdwnr9f3k7t">Introduction</a></span></p><p class="c6 c17"><span class="c3"><a class="c11" href="#h.q5igxepx5vkl">Lexical Analyzer</a></span></p><p class="c6 c12"><span class="c3"><a class="c11" href="#h.vncwqeo2o4ts">Examples</a></span></p><p class="c6 c12"><span class="c3"><a class="c11" href="#h.9ghbzfuszc2u">Line number</a></span></p><p class="c6 c12"><span class="c3"><a class="c11" href="#h.p4lp2gr4fr92">Numbers</a></span></p><p class="c6 c12"><span class="c3"><a class="c11" href="#h.9sfkd92liy1">Comments</a></span></p><p class="c6 c17"><span class="c3"><a class="c11" href="#h.w2wmcxmmrbtk">Syntax Analyzer</a></span></p><p class="c6 c12"><span class="c3"><a class="c11" href="#h.w62kvwc0uaoy">Precedence of IF and IF ELSE Statement</a></span></p><p class="c6 c12"><span class="c3"><a class="c11" href="#h.eonp3nb1gbpn">Error Message</a></span></p><p class="c6 c12"><span class="c3"><a class="c11" href="#h.rhouzduey44h">Node reduction and modification</a></span></p><p class="c6 c18"><span class="c3"><a class="c11" href="#h.16njz18miwqn">Reduction</a></span></p><p class="c6 c18"><span class="c3"><a class="c11" href="#h.y023xnqzlqmm">Modification</a></span></p><p class="c6 c17"><span class="c3"><a class="c11" href="#h.abn9t5g9sh0w">Semantic Analyzer</a></span></p><p class="c6 c12"><span class="c3"><a class="c11" href="#h.jfnevnw9gs19">Parse Tree Generation</a></span></p><p class="c6 c12"><span class="c3"><a class="c11" href="#h.6m0yts5pj6rn">Examples</a></span></p><p class="c6 c12"><span class="c3"><a class="c11" href="#h.83ca20x1oz22">Symbol Table</a></span></p><p class="c6 c12"><span class="c3"><a class="c11" href="#h.950lxchkc2yw">Error Checking</a></span></p><p class="c6 c18"><span class="c3"><a class="c11" href="#h.4ywx7ponh57g">Auto conversion</a></span></p><p class="c6 c18"><span class="c3"><a class="c11" href="#h.8saj9xt5u3gu">operand type checking</a></span></p><p class="c6 c18"><span class="c3"><a class="c11" href="#h.e8q4dzvon3j9">Resevered word</a></span></p><p class="c6 c18"><span class="c3"><a class="c11" href="#h.v6llbveznqrz">Main entrance</a></span></p><p class="c6 c18"><span class="c3"><a class="c11" href="#h.6187kdv3bs8s">Usage after declaration</a></span></p><p class="c6 c18"><span class="c3"><a class="c11" href="#h.ixq27grp1roa">Break &amp; continue</a></span></p><p class="c6 c17"><span class="c3"><a class="c11" href="#h.wqebhch71hcs">Intermediate Representation</a></span></p><p class="c6 c12"><span class="c3"><a class="c11" href="#h.6vxrhwyr0bce">Data Structure</a></span></p><p class="c6 c17"><span class="c3"><a class="c11" href="#h.wqebhch71hcs">Register Allocation</a></span></p><p class="c6 c17"><span class="c3"><a class="c11" href="#h.wqebhch71hcs">Optimization</a></span></p><p class="c6 c12"><span class="c3"><a class="c11" href="#h.e3u5r1ufj578">Unused function</a></span></p><p class="c6 c12"><span class="c3"><a class="c11" href="#h.9cu2ru8y497k">Unused struct definition</a></span></p><p class="c6 c17"><span class="c3"><a class="c11" href="#h.8a186ye4abu6">Conclusion</a></span></p><p class="c6 c12"><span class="c3"><a class="c11" href="#h.5d1mbw6vzg4p">Philosophy</a></span></p><p class="c6 c17"><span class="c3"><a class="c11" href="#h.2evc1faqyfiq">Reference</a></span></p><h1 class="c6 c22"><a id="h.shdwnr9f3k7t" name="h.shdwnr9f3k7t"></a><span>Introduction</span></h1><p class="c6"><span>In this project, you are required to implement a code generator to translate the intermediate representation, which is produced by your syntax analyzer implemented in project 1, into LLVM instructions. Your code generator should return a LLVM assembly program, which can be run on LLVM (http://llvm.org/). After finishing this project, you will get a compiler, which can translate Small-C source programs to LLVM assembly programs.</span></p><h1 class="c6 c22"><a id="h.q5igxepx5vkl" name="h.q5igxepx5vkl"></a><span>Lexical Analyzer</span></h1><p class="c6"><span>Here we will use flex as the tool of lexical analyzer and we can work under the framework with only spcifying the regex expression and the according action.</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 602.00px; height: 350.67px;"><img alt="" src="images/image03.png" style="width: 602.00px; height: 350.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h2 class="c6 c22"><a id="h.vncwqeo2o4ts" name="h.vncwqeo2o4ts"></a><span>Examples</span></h2><p class="c6"><span>Since the logic are pretty the same for all symbols, we use define to avoid duplicate and if you want to change some logic, you only need to fix the define instead of fixing them one by one.</span></p><p class="c6 c9"><span></span></p><a href="#" id="a4a8fa04c2564d84de2aeffd9a99ee45dbc6bc12" name="a4a8fa04c2564d84de2aeffd9a99ee45dbc6bc12"></a><a href="#" id="0" name="0"></a><table cellpadding="0" cellspacing="0" class="c14"><tbody><tr class="c8"><td class="c30" colspan="1" rowspan="1"><p class="c13 c6"><span class="c4 c20">#define</span><span class="c4">&nbsp;printReturn</span><span class="c0">(</span><span class="c4">x</span><span class="c0">)</span><span class="c4">&nbsp; </span><span class="c4 c28">return</span><span class="c23 c2">&nbsp;x;</span></p><p class="c13 c6"><span class="c4 c20">#define</span><span class="c4">&nbsp;load yylval</span><span class="c0">.</span><span class="c4 c28">string</span><span class="c4">&nbsp;</span><span class="c0">=</span><span class="c4">&nbsp;strdup</span><span class="c0">(</span><span class="c4">yytext</span><span class="c0">);</span></p><p class="c13 c6"><span class="c0">&hellip;...</span></p><p class="c6 c13"><span class="c4 c21">&quot;/&quot;</span><span class="c4">&nbsp;</span><span class="c0">{</span><span class="c4">load printReturn</span><span class="c0">(</span><span class="c4">DIV_OP</span><span class="c0">)}</span></p><p class="c13 c6"><span class="c4 c21">&quot;%&quot;</span><span class="c4">&nbsp;</span><span class="c0">{</span><span class="c4">load printReturn</span><span class="c0">(</span><span class="c4">MOD_OP</span><span class="c0">)}</span></p><p class="c13 c6"><span class="c4 c21">&quot;&lt;&quot;</span><span class="c4">&nbsp;</span><span class="c0">{</span><span class="c4">load printReturn</span><span class="c0">(</span><span class="c4">LT_OP</span><span class="c0">)}</span></p></td></tr></tbody></table><p class="c6 c9"><span></span></p><h2 class="c6 c22"><a id="h.9ghbzfuszc2u" name="h.9ghbzfuszc2u"></a><span>Line number</span></h2><p class="c6"><span>For the debug purpose for me and for whoever use this compiler, it is very important that you tell user why and where it does not work.</span></p><p class="c6 c9"><span></span></p><a href="#" id="162479c1b8c74bfee0e8048a00c41897f821f773" name="162479c1b8c74bfee0e8048a00c41897f821f773"></a><a href="#" id="1" name="1"></a><table cellpadding="0" cellspacing="0" class="c14"><tbody><tr class="c8"><td class="c30" colspan="1" rowspan="1"><p class="c13 c6"><span class="c0">[</span><span class="c4">\n</span><span class="c0">]</span><span class="c4">&nbsp;</span><span class="c0">{</span><span class="c4">yylineno </span><span class="c0">=</span><span class="c4">&nbsp;yylineno</span><span class="c0">+</span><span class="c4 c26">1</span><span class="c0">;}</span></p></td></tr></tbody></table><h2 class="c6 c22"><a id="h.p4lp2gr4fr92" name="h.p4lp2gr4fr92"></a><span>Numbers</span></h2><p class="c6"><span>We will only handle positive value here, as for minus sign before it, we will handle it later in semantic analyzer. Note that we will treat number start with 0, and 0x, 0X as valid number. And alphabet will only appear in literals start with 0x or 0X.</span></p><p class="c6 c9"><span></span></p><a href="#" id="79b8e9d5a587549ae4c2f6127a1b327947be2a1c" name="79b8e9d5a587549ae4c2f6127a1b327947be2a1c"></a><a href="#" id="2" name="2"></a><table cellpadding="0" cellspacing="0" class="c14"><tbody><tr class="c8"><td class="c30" colspan="1" rowspan="1"><p class="c13 c6"><span class="c0">([</span><span class="c4 c26">0</span><span class="c0">-</span><span class="c4 c26">9</span><span class="c0">]*|</span><span class="c4 c26">0</span><span class="c0">[</span><span class="c4">xX</span><span class="c0">][</span><span class="c4 c26">0</span><span class="c0">-</span><span class="c4 c26">9a</span><span class="c0">-</span><span class="c4">fA</span><span class="c0">-</span><span class="c4">F</span><span class="c0">]+)</span><span class="c4">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c0">{</span><span class="c4">&nbsp;load printReturn</span><span class="c0">(</span><span class="c4">INT</span><span class="c0">)</span><span class="c4">&nbsp;}</span></p></td></tr></tbody></table><p class="c6 c9"><span></span></p><h2 class="c6 c22"><a id="h.9sfkd92liy1" name="h.9sfkd92liy1"></a><span>Comments</span></h2><p class="c6"><span>For comments, there are two formats.</span></p><p class="c6"><span>one line comments is handled by such:</span></p><p class="c6 c9"><span></span></p><a href="#" id="8fba74d3d4bca1fe694d3db0e6b49d37cf22187d" name="8fba74d3d4bca1fe694d3db0e6b49d37cf22187d"></a><a href="#" id="3" name="3"></a><table cellpadding="0" cellspacing="0" class="c14"><tbody><tr class="c8"><td class="c30" colspan="1" rowspan="1"><p class="c13 c6"><span class="c4 c19 c31">&quot;//&quot;(.)* &nbsp;{}</span></p></td></tr></tbody></table><p class="c6 c9"><span></span></p><p class="c6 c9"><span></span></p><p class="c6"><span>And comments block will be handled by a more trick strategy which involves state transition:</span></p><p class="c6 c9"><span></span></p><a href="#" id="bdf6c833d8806b2899feaf96ba234255648ead56" name="bdf6c833d8806b2899feaf96ba234255648ead56"></a><a href="#" id="4" name="4"></a><table cellpadding="0" cellspacing="0" class="c14"><tbody><tr class="c8"><td class="c30" colspan="1" rowspan="1"><p class="c13 c6"><span class="c4 c31 c19">%x COMMENT</span></p><p class="c13 c6"><span class="c16">...</span></p><p class="c13 c6"><span class="c4">&nbsp;</span><span class="c4 c19 c21">&quot;/*&quot;</span><span class="c4 c19">&nbsp; &nbsp; &nbsp; </span><span class="c4 c28 c19">BEGIN</span><span class="c0 c19">(</span><span class="c4 c19">COMMENT</span><span class="c0 c19">);</span></p><p class="c13 c6"><span class="c4 c28 c19">&lt;comment&gt;{</span></p><p class="c13 c6"><span class="c0 c19">[^*]*</span><span class="c7 c2">&nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c13 c6"><span class="c4 c19 c21">&quot;*&quot;</span><span class="c0 c19">+[^*/]*</span><span class="c7 c2">&nbsp; &nbsp;</span></p><p class="c13 c6"><span class="c7 c2">\n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span></p><p class="c13 c6"><span class="c4 c19 c21">&quot;*&quot;</span><span class="c0 c19">+</span><span class="c4 c19 c21">&quot;/&quot;</span><span class="c4 c19">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c4 c28 c19">BEGIN</span><span class="c0 c19">(</span><span class="c4 c19">INITIAL</span><span class="c0 c19">);// &nbsp; ******/</span></p><p class="c13 c6"><span class="c4 c19">}</span></p></td></tr></tbody></table><p class="c6 c9"><span></span></p><h1 class="c6 c22"><a id="h.w2wmcxmmrbtk" name="h.w2wmcxmmrbtk"></a><span>Syntax Analyzer</span></h1><p class="c6"><span>In the file smallc.y, we define the syntax rules. We define precedence and translation rules. Along with which we also specify the structure of the node so that we can get a parse tree after parsing the file.</span></p><h2 class="c6 c22"><a id="h.w62kvwc0uaoy" name="h.w62kvwc0uaoy"></a><span>Precedence of IF and IF ELSE Statement</span></h2><p class="c6"><span>For expression IF LP EXPS RP STMT and IF LP EXPS RP STMT ELSE STMT, if we don&rsquo;t give them precedence, then the parser may have a confilct that may be both pattern can be used , so we need to specify the precedence that IF LP EXPS RP STMT ELSE STMT has higher priority than the other one.</span></p><p class="c6 c9"><span></span></p><a href="#" id="d53841ab95039c22deaefb6bcdf9eed031dfdfae" name="d53841ab95039c22deaefb6bcdf9eed031dfdfae"></a><a href="#" id="5" name="5"></a><table cellpadding="0" cellspacing="0" class="c14"><tbody><tr class="c8"><td class="c30" colspan="1" rowspan="1"><p class="c13 c6"><span class="c0">%</span><span class="c23 c2">nonassoc &nbsp;IF_NO_ELSE</span></p><p class="c13 c6"><span class="c0">%</span><span class="c23 c2">nonassoc ELSE_AFTER_IF</span></p><p class="c13 c6"><span class="c0">&hellip;.</span></p><p class="c13 c6 c9"><span class="c23 c2"></span></p><p class="c13 c6"><span class="c4">STMT</span><span class="c0">: </span></p><p class="c13 c6"><span class="c0">...</span></p><p class="c13 c6"><span class="c0">|</span><span class="c4">&nbsp;IF LP EXPS RP STMT </span><span class="c0">%</span><span class="c4">prec IF_NO_ELSE </span><span class="c0">{</span><span class="c4">&nbsp;$$ </span><span class="c0">=</span><span class="c4">&nbsp;getNodeInstance</span><span class="c0">(</span><span class="c4">yylineno</span><span class="c0">,</span><span class="c4 c21">&quot;STMT&quot;</span><span class="c4">&nbsp;</span><span class="c0">,</span><span class="c4 c21">&quot;STMT: if ( EXPS ) STMT&quot;</span><span class="c0">,</span><span class="c4">&nbsp;</span><span class="c4 c26">2</span><span class="c0">,</span><span class="c4">&nbsp;$3</span><span class="c0">,</span><span class="c4">$5</span><span class="c0">);</span><span class="c23 c2">&nbsp;}</span></p><p class="c13 c6"><span class="c0">|</span><span class="c4">&nbsp;IF LP EXPS RP STMT ELSE STMT </span><span class="c0">%</span><span class="c4">prec ELSE_AFTER_IF </span><span class="c0">{</span><span class="c4">&nbsp;$$ </span><span class="c0">=</span><span class="c4">&nbsp;getNodeInstance</span><span class="c0">(</span><span class="c4">yylineno</span><span class="c0">,</span><span class="c4 c21">&quot;STMT&quot;</span><span class="c0">,</span><span class="c4">&nbsp;</span><span class="c4 c21">&quot;STMT: if ( EXPS ) STMT else STMT&quot;</span><span class="c0">,</span><span class="c4">&nbsp;</span><span class="c4 c26">3</span><span class="c0">,</span><span class="c4">&nbsp;$3</span><span class="c0">,</span><span class="c4">$5</span><span class="c0">,</span><span class="c4">$7</span><span class="c0">);}</span></p></td></tr></tbody></table><p class="c6 c9"><span></span></p><p class="c6 c9"><span></span></p><h2 class="c6 c22"><a id="h.eonp3nb1gbpn" name="h.eonp3nb1gbpn"></a><span>Error Message</span></h2><p class="c6"><span>we override the error funciton yyerror that it will give the line number for better debug purpose.</span></p><p class="c6 c9"><span></span></p><p class="c6 c9"><span class="c2"></span></p><a href="#" id="8522e02925031e0a0abff475084f90b63b6d294e" name="8522e02925031e0a0abff475084f90b63b6d294e"></a><a href="#" id="6" name="6"></a><table cellpadding="0" cellspacing="0" class="c14"><tbody><tr class="c8"><td class="c30" colspan="1" rowspan="1"><p class="c13 c6"><span class="c4 c28">void</span><span class="c4">&nbsp;yyerror</span><span class="c0">(</span><span class="c4 c28">char</span><span class="c4">&nbsp;</span><span class="c0">*</span><span class="c23 c2">s)</span></p><p class="c13 c6"><span class="c23 c2">{</span></p><p class="c13 c6"><span class="c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fflush</span><span class="c0">(</span><span class="c4">stdout</span><span class="c0">);</span></p><p class="c13 c6"><span class="c4">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf</span><span class="c0">(</span><span class="c4">stderr</span><span class="c0">,</span><span class="c4 c21">&quot;yyerror: %d :%s %s\n&quot;</span><span class="c0">,</span><span class="c4">yylineno</span><span class="c0">,</span><span class="c4">s</span><span class="c0">,</span><span class="c4">yytext</span><span class="c0">);</span></p><p class="c13 c6"><span class="c23 c2">}</span></p></td></tr></tbody></table><p class="c6 c9"><span></span></p><h2 class="c6 c22"><a id="h.rhouzduey44h" name="h.rhouzduey44h"></a><span>Node reduction and modification</span></h2><h3 class="c6 c22"><a id="h.16njz18miwqn" name="h.16njz18miwqn"></a><span>Reduction</span></h3><p class="c6"><span>In the given material, there are some grammer like:</span></p><p class="c6"><span class="c2">STSPEC </span><span class="c0">&rarr;</span><span class="c2">&nbsp;STRUCT OPTTAG LC DEFS RC </span><span class="c0">|</span><span class="c2">&nbsp;STRUCT ID</span></p><p class="c6"><span class="c2">OPTTAG </span><span class="c0">&rarr;</span><span class="c2">&nbsp;ID </span><span class="c0">|</span><span class="c2">&nbsp;&#1013;</span></p><p class="c6 c9"><span class="c2"></span></p><p class="c6"><span class="c2">EXTDEF </span><span class="c0">&rarr;</span><span class="c2">&nbsp;SPEC EXTVARS SEMI </span><span class="c0">|</span><span class="c2">&nbsp;SPEC FUNC STMTBLOCK</span></p><p class="c6"><span class="c2">SPEC </span><span class="c0">&rarr;</span><span class="c2">&nbsp;TYPE </span><span class="c0">|</span><span class="c2">&nbsp;STSPEC</span></p><p class="c6 c9"><span class="c2"></span></p><p class="c6"><span class="c2">STMT </span><span class="c0">&rarr;</span><span class="c2">&nbsp;IF LP EXP RP STMT ESTMT &nbsp;</span><span class="c0">|</span><span class="c2">&nbsp;</span><span class="c0">...</span></p><p class="c6"><span class="c2">ESTMT </span><span class="c0">&rarr;</span><span class="c2">&nbsp;ELSE STMT </span><span class="c0">|</span><span class="c2">&nbsp;&#1013;</span></p><p class="c6 c9"><span></span></p><p class="c6"><span>I change the grammer by merging the rules. so that I can translate the code in a higher level of the grammer tree. I merge the rules to this:</span></p><p class="c6 c9"><span></span></p><p class="c6"><span class="c2">STSPEC </span><span class="c0">&rarr;</span><span class="c2">&nbsp;STRUCT ID LC DEFS RC</span></p><p class="c6"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c0">|</span><span class="c2">&nbsp;STRUCT LC DEFS RC</span></p><p class="c6 c24"><span class="c0">|</span><span class="c2">&nbsp;STRUCT ID</span></p><p class="c6 c24 c9"><span class="c2"></span></p><p class="c6"><span class="c2">EXTDEF </span><span class="c0">&rarr;</span><span class="c2">&nbsp;TYPE EXTVARS SEMI </span></p><p class="c6 c24"><span class="c0">|</span><span class="c2">&nbsp;TYPE FUNC STMTBLOCK</span></p><p class="c6 c24"><span class="c0">|</span><span class="c2">&nbsp;STSPEC SEXTVARS SEMI </span><span class="c4 c20">//(by introtucing SEXTVARS to distinguish struct def)</span></p><p class="c6 c24 c9"><span class="c2"></span></p><p class="c6 c9"><span class="c2"></span></p><p class="c6"><span class="c2">STMT </span><span class="c0">&rarr;</span><span class="c2">&nbsp;IF LP EXP RP STMT &nbsp;</span></p><p class="c6 c24"><span class="c0">|</span><span class="c2">&nbsp;IF LP EXP RP STMT ELSE STMT</span></p><p class="c6 c12"><span class="c0">|...</span></p><h3 class="c6 c22"><a id="h.y023xnqzlqmm" name="h.y023xnqzlqmm"></a><span>Modification</span></h3><p class="c6"><span>Since situation like if (EXP) will not be acceptable if EXP is empty, I introduce EXPS as such:</span></p><p class="c6"><span class="c2">EXP </span><span class="c0">-&gt;</span><span class="c2">&nbsp;EXPS</span></p><p class="c6 c24"><span class="c0">|</span><span class="c2">&nbsp;&#1013;</span></p><p class="c6"><span>EXPS are defined as exp before but it can not be empty and modify if(EXP) to if(EXPS)</span></p><h1 class="c6 c22"><a id="h.abn9t5g9sh0w" name="h.abn9t5g9sh0w"></a><span>Semantic Analyzer </span></h1><p class="c6"><span>We use polymorphism as our main method in generating parse tree. Our Data structure is as such, there is a base class called TreeNode. And there are a lot of class inheriting the base class and will override the function Codegen() and isEmit();</span></p><p class="c6 c9"><span></span></p><p class="c6"><span>Derived from the base class, we implement more than 20 derived class such as EXPTreeNode , STMTTreeNode etc. </span></p><p class="c6 c9"><span></span></p><p class="c6"><span>Function getNodeInstance will judge on the input argument and decide which kind of TreeNode class to return. And that class will have it&rsquo;s own implementation of Codegen(). When parent node is called function Codegen(), it can directly call children class to excute their Codegen() without knowing what kind of child class it is calling.</span></p><p class="c6 c9"><span></span></p><p class="c6"><span>isEmit is for optimization purpose, if some class override the default function, then the node will be neglected if isEmit() function return false. This is for dead code elimination purpose.</span></p><p class="c6 c9"><span></span></p><p class="c6"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 586.50px; height: 519.00px;"><img alt="" src="images/image00.png" style="width: 586.50px; height: 519.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c6"><span>Codegen() will generate code by pushing back Code class to a vector of code. Code is stored by lines or by instructions. It include template which idicate the instrcution selection, comment that for debug purpose and register used in instruction. In our implementation , comment will include the infomation of the path from the calling node to the root node. </span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 186.67px; height: 196.00px;"><img alt="" src="images/image01.png" style="width: 186.67px; height: 196.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h2 class="c6 c22"><a id="h.jfnevnw9gs19" name="h.jfnevnw9gs19"></a><span>Parse Tree Generation</span></h2><h2 class="c6 c22"><a id="h.6m0yts5pj6rn" name="h.6m0yts5pj6rn"></a><span>Examples</span></h2><p class="c6"><span>I will demostrate how for expression is constructed.</span></p><p class="c6 c9"><span></span></p><a href="#" id="972cd5c2444dca15c71b37ced95ab34a7ba50cc1" name="972cd5c2444dca15c71b37ced95ab34a7ba50cc1"></a><a href="#" id="7" name="7"></a><table cellpadding="0" cellspacing="0" class="c14"><tbody><tr class="c8"><td class="c30" colspan="1" rowspan="1"><p class="c13 c6"><span class="c4">STMT</span><span class="c0">:</span><span class="c4">&nbsp; FOR LP EXP SEMI EXP SEMI EXP RP STMT </span><span class="c0">{</span><span class="c4">&nbsp;$$ </span><span class="c0">=</span><span class="c4">&nbsp;getNodeInstance</span><span class="c0">(</span><span class="c4">yylineno</span><span class="c0">,</span><span class="c4">&nbsp;</span><span class="c4 c21">&quot;STMT&quot;</span><span class="c0">,</span><span class="c4 c21">&quot;STMT: for ( EXP ; EXP ; EXP ) STMT&quot;</span><span class="c0">,</span><span class="c4">&nbsp;</span><span class="c4 c26">4</span><span class="c0">,</span><span class="c4">&nbsp;$3</span><span class="c0">,</span><span class="c4">$5</span><span class="c0">,</span><span class="c4">$7</span><span class="c0">,</span><span class="c4">$9</span><span class="c0">);</span><span class="c4">&nbsp;}</span></p></td></tr></tbody></table><p class="c6 c9"><span class="c2"></span></p><p class="c6 c9"><span class="c36"></span></p><p class="c6"><span>getNodeInstance will return a TreeNode class based on arguments, here we pass &ldquo;STMT&rdquo; into the function and this funciton will return a STMTTreeNode Class. And it will has 4 children, pointer of which will be represented as $3, $5, $7, $9. And the returned STMTTreeNode may be treated as a child by other TreeNode.</span></p><p class="c6 c9"><span></span></p><h2 class="c6 c22"><a id="h.83ca20x1oz22" name="h.83ca20x1oz22"></a><span>Symbol Table</span></h2><p class="c6"><span>Symbol table is stored in each TreeNode, we make this design to support the senario where same name appear in different layer of code like:</span></p><p class="c6 c9"><span></span></p><p class="c6"><span class="c4 c28">int</span><span class="c2">&nbsp;a;</span></p><p class="c6"><span class="c4 c28">int</span><span class="c2">&nbsp;main{</span></p><p class="c6"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c4 c28">int</span><span class="c2">&nbsp;a</span><span class="c0">=</span><span class="c4 c26">0;</span></p><p class="c6"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c4 c28">int</span><span class="c2">&nbsp;c</span><span class="c0">=</span><span class="c4 c26">0;</span></p><p class="c6"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c4 c28">if</span><span class="c0">(</span><span class="c2">a</span><span class="c0">=</span><span class="c4 c26">0</span><span class="c0">){</span></p><p class="c6"><span class="c2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c4 c28">int</span><span class="c2">&nbsp;c</span><span class="c0">=1;</span></p><p class="c6 c24"><span class="c2">}</span></p><p class="c6 c24"><span class="c4 c28">return</span><span class="c2">&nbsp;</span><span class="c4 c26">0;</span></p><p class="c6"><span class="c2">}</span></p><p class="c6 c9"><span class="c4"></span></p><p class="c6"><span>Only STMTBLOCKTreeNode and PROGRAMTreeNode has meaningful symbol table, for other type of nodes, the symbol table should be empty.</span></p><p class="c6"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 613.50px; height: 633.13px;"><img alt="" src="images/image02.png" style="width: 613.50px; height: 633.13px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c6"><span>As the figure suggests, when a node want to retrieving a symbol, it will first look up to the nearest STMTBOLCK node or PROGRAM node, and check if the symbol is in the table, if not find it, it will futher go to upper node until arrive root node.</span></p><p class="c6 c9"><span></span></p><p class="c6"><span>For saving process, toward the root direction, it will save this symbol to the nearest symbol table.</span></p><p class="c6 c9"><span></span></p><p class="c6"><span>The symbol table is resposible to make a map between the varible in smallc to a unique name in LLVM. And Symbol table in Program holds global variable, while Symbol table in STMTBOLCK holds local variable. Other node&rsquo;s symbol table will be empty. </span></p><h2 class="c6 c22"><a id="h.950lxchkc2yw" name="h.950lxchkc2yw"></a><span>Error Checking</span></h2><h3 class="c6 c22"><a id="h.4ywx7ponh57g" name="h.4ywx7ponh57g"></a><span>Auto conversion</span></h3><p class="c6"><span>For situation of &#65306;</span></p><p class="c6 c9"><span></span></p><p class="c6"><span class="c4 c28">if</span><span class="c2">&nbsp;</span><span class="c0">(</span><span class="c2">exps)</span></p><p class="c6"><span class="c4 c28">for</span><span class="c0">(</span><span class="c2">exp</span><span class="c0">;</span><span class="c2">exp</span><span class="c0">;</span><span class="c2">exp)</span></p><p class="c6 c9"><span class="c4"></span></p><p class="c6"><span>The value inside if bracket and second value of exp should be a bool value, but generally in most grammer, int, string and other varible that are not empty or not zero will be concidered as true. Here after the calculation of the exps, we will do the auto conversion, if and i32 is returned , it will be compared to zero to generate a bool value.</span></p><h3 class="c6 c22"><a id="h.8saj9xt5u3gu" name="h.8saj9xt5u3gu"></a><span>operand type checking</span></h3><ol class="c33 lst-kix_o5amvn4w35l-0 start" start="1"><li class="c5"><span>for Dot and [] , we will first check if the operand is valid or not. If it is not valid, we will log warning and exit the program.</span></li><li class="c5"><span>for return statment, I will check if the return register is a i32 format.</span></li></ol><h3 class="c6 c22"><a id="h.e8q4dzvon3j9" name="h.e8q4dzvon3j9"></a><span>Resevered word</span></h3><p class="c6"><span>Id can not be reserved word, this is implemented by the flex and yacc, it will treat reserve word a symbol and parse it by that symbol&rsquo;s way. It will generate an error in syntaxtree building process.</span></p><h3 class="c6 c22"><a id="h.v6llbveznqrz" name="h.v6llbveznqrz"></a><span>Main entrance</span></h3><p class="c6"><span>We will check is the function main exist after we finish parsing the code.</span></p><h3 class="c6 c22"><a id="h.6187kdv3bs8s" name="h.6187kdv3bs8s"></a><span>Usage after declaration</span></h3><p class="c6"><span>This part is implemented with symbol table, when encountered a symbol, it will try to retrive the symbol in the path of node toward the root. If no such symbol is found, it will generate a error message and exit with -1.</span></p><h3 class="c6 c22"><a id="h.ixq27grp1roa" name="h.ixq27grp1roa"></a><span>Break &amp; continue</span></h3><p class="c6"><span>We use a stack to maintain if program is inside a for loop, in each for loop, we will push the break label and continue label into the stack, when encounter a break or continue, it will first check if the stack is empty and then jump to the label on the top of the stack.</span></p><p class="c6 c9"><span></span></p><h3 class="c6 c22"><a id="h.qzfzthzb3xmh" name="h.qzfzthzb3xmh"></a><span>Function checking and Struct definition checking</span></h3><p class="c6"><span>When program call a funciton or declare a struct, we will check if it has been defined globally.</span></p><h1 class="c6 c22"><a id="h.9floka8t3zo" name="h.9floka8t3zo"></a><span>Intermediate Representation</span></h1><h2 class="c6 c22"><a id="h.cis1lf1qjqpf" name="h.cis1lf1qjqpf"></a><span>Learning LLVM basic knowledge</span></h2><p class="c6"><span>&nbsp;</span></p><a href="#" id="c066d1b6c4830fa4c54e7f745f115a165354a451" name="c066d1b6c4830fa4c54e7f745f115a165354a451"></a><a href="#" id="8" name="8"></a><table cellpadding="0" cellspacing="0" class="c14"><tbody><tr class="c8"><td class="c10" colspan="1" rowspan="1"><p class="c15"><span class="c16">small c</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c15"><span class="c16">translation template</span></p></td></tr><tr class="c8"><td class="c10" colspan="1" rowspan="1"><p class="c15"><span class="c23 c25">read</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c15"><span class="c23 c25">%s = call i32 (i8*, ...)* @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8]* @.str, i32 0, i32 0), i32* %s)</span></p><p class="c15 c9"><span class="c23 c25"></span></p></td></tr><tr class="c8"><td class="c10" colspan="1" rowspan="1"><p class="c15"><span class="c23 c25">write (other funciton call are similar)</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c15"><span class="c23 c25">%s = call i32 (i8*, ...)* @__isoc99_scanf(i8* getelementptr inbounds ([3 x i8]* @.str, i32 0, i32 0), i32* %s)</span></p><p class="c15 c9"><span class="c23 c25"></span></p></td></tr><tr class="c8"><td class="c10" colspan="1" rowspan="1"><p class="c15"><span class="c23 c25">continue, break</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c15"><span class="c23 c25">br label %%%s</span></p><p class="c15 c9"><span class="c23 c25"></span></p></td></tr><tr class="c8"><td class="c10" colspan="1" rowspan="1"><p class="c15"><span class="c23 c25">return </span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c15"><span class="c23 c25">ret i32 %s</span></p><p class="c15 c9"><span class="c23 c25"></span></p></td></tr><tr class="c8"><td class="c10" colspan="1" rowspan="1"><p class="c15"><span class="c23 c25">int a</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c15"><span class="c23 c25">%s = allocal i32, align 4</span></p><p class="c15"><span class="c23 c25">%s &nbsp;= common global i32 0, align 4</span></p></td></tr><tr class="c8"><td class="c10" colspan="1" rowspan="1"><p class="c15"><span class="c23 c25">int a[4]</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c15"><span class="c27">%s &nbsp;= common global [ </span><span class="c27">4</span><span class="c23 c25">&nbsp;x i32] zeroinitializer, align 4</span></p><p class="c15"><span class="c27">%s = alloca [ </span><span class="c27">4</span><span class="c23 c25">&nbsp;x i32] , align 4</span></p><p class="c15 c9"><span class="c23 c25"></span></p></td></tr><tr class="c8"><td class="c10" colspan="1" rowspan="1"><p class="c15"><span class="c23 c25">struct a={ &hellip;}</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c15"><span class="c23 c25">%s = type {i32, i32&hellip;} </span></p></td></tr><tr class="c8"><td class="c10" colspan="1" rowspan="1"><p class="c15"><span class="c16">a=b</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c15"><span class="c1">%s= load i32* %b, align 4</span></p><p class="c15"><span class="c1">save i32 %s , i32* %a, align 4</span></p></td></tr><tr class="c8"><td class="c10" colspan="1" rowspan="1"><p class="c15"><span class="c16">a+b (other binary operation is similar)</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c15"><span class="c1">%s = add i32 %1, %2</span></p></td></tr><tr class="c8"><td class="c10" colspan="1" rowspan="1"><p class="c15"><span class="c16">a==b (other compare operation is similar)</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c15"><span class="c1">%s = icmp eq i32 %a, %b</span></p></td></tr><tr class="c8"><td class="c10" colspan="1" rowspan="1"><p class="c15"><span class="c16">++a (other unary operand is similar)</span></p></td><td class="c10" colspan="1" rowspan="1"><p class="c15"><span class="c1">%a= load i32* %ptr_a, align 4</span></p><p class="c15"><span class="c1">%s =add i32 %a, 1</span></p><p class="c15"><span class="c1">save i32 %s, i32* %ptr_a </span></p></td></tr></tbody></table><h2 class="c6 c22 c34"><a id="h.6vxrhwyr0bce" name="h.6vxrhwyr0bce"></a></h2><h1 class="c6 c22"><a id="h.pswnppwndaic" name="h.pswnppwndaic"></a><span>Register Allocation</span></h1><p class="c6"><span>Alougth llvm can have infinite variables and llvm will do register allocation inside it, we still do register allocation for practice.</span></p><p class="c6 c9"><span></span></p><p class="c6"><span>Note that llvm does not allow the following grammer:</span></p><p class="c6 c9"><span></span></p><p class="c6"><span class="c0">%</span><span class="c2">r3 </span><span class="c0">=</span><span class="c2">&nbsp;add i32 </span><span class="c0">%</span><span class="c2">r1</span><span class="c0">,</span><span class="c2">&nbsp;</span><span class="c0">%</span><span class="c2">r2</span></p><p class="c6"><span class="c0">&hellip;.</span></p><p class="c6"><span class="c0">%</span><span class="c2">r3 </span><span class="c0">=</span><span class="c2">&nbsp;add i32 </span><span class="c0">%</span><span class="c2">r1</span><span class="c0">,</span><span class="c2">&nbsp;</span><span class="c0">%</span><span class="c2">r4</span></p><p class="c6 c9"><span></span></p><p class="c6"><span>This means that one variable can only be assigned a value once. Because of that I named my register with two parts like: %r_45.fp323. The first part is %r_45, meaning that it is a register, and it is register 45, fp323 is short for figerprints 323. Finger prints is to make sure that the register is not the same for llvm. But if we are going to help llvm implement register allocation, then the fingerprint part can be neglected. </span></p><p class="c6 c9"><span></span></p><p class="c6"><span>There are three cases where we need to handle register.</span></p><ol class="c33 lst-kix_ys1gkzcwbzip-0 start" start="1"><li class="c5"><span>read/write return value.</span></li></ol><ol class="c33 lst-kix_ys1gkzcwbzip-1 start" start="1"><li class="c6 c35"><span>when read and write are called, a function call will return a int. And that int will be abandoned.</span></li></ol><ol class="c33 lst-kix_ys1gkzcwbzip-0" start="2"><li class="c5"><span>EXP calculation</span></li><li class="c5"><span>initialization of the array,</span></li></ol><ol class="c33 lst-kix_ys1gkzcwbzip-1 start" start="1"><li class="c6 c35"><span>we need to first get the pointer to the value</span></li><li class="c6 c35"><span>then store value to that pointer, after that this pointer is of no use.</span></li></ol><p class="c6 c9 c12"><span></span></p><p class="c6"><span>For first and third situation, since they will be abandoned after one time use. They will handled by adhoc method. We do register allocation for the second situation.</span></p><p class="c6 c9"><span></span></p><p class="c6"><span>Our register allocation Algorithm is like this:</span></p><ol class="c33 lst-kix_kph9ph6y19yr-0 start" start="1"><li class="c5"><span>we maintain an int registerNumber and set&lt;stirng&gt; freeRegister.</span></li><li class="c5"><span>if freeReg is called, then the reg is add to freeRegister.</span></li><li class="c5"><span>if allocateReg is called, then it will give the first element of freeRegister(also the smallest one since set is implemented as BST) if freeRegister is empty then increment registerNumber and return a newly created name.</span></li></ol><p class="c6 c9"><span></span></p><p class="c6"><span>freeReg is called by the programmer who write the compiler (i.e me). basically I will freeReg all regs except the return one when finish the calculation of the EXPS. </span></p><h1 class="c6 c22"><a id="h.wqebhch71hcs" name="h.wqebhch71hcs"></a><span>Optimization</span></h1><h2 class="c6 c22"><a id="h.nod9mdlgp13" name="h.nod9mdlgp13"></a><span>Unused function</span></h2><p class="c6"><span>For unused funciton , I will directly remove that EXTDEFSTreeNode.</span></p><h2 class="c6 c22"><a id="h.m8evzzt3jkcb" name="h.m8evzzt3jkcb"></a><span>Unused struct definition</span></h2><p class="c6"><span>For unused struct definition, I will directly remove that EXTDEFSTreeNode.</span></p><h1 class="c6 c22"><a id="h.t0q78v34pdgt" name="h.t0q78v34pdgt"></a><span>Conclusion</span></h1><p class="c6"><span>My compiler has passed the given test and </span><span class="c3"><a class="c11" href="https://www.google.com/url?q=https://github.com/jiady/compiler-llvm/tree/master/5120309607_prj2/testcase/new_test&amp;sa=D&amp;ust=1453306343846000&amp;usg=AFQjCNGbSFh09_ifV-lMxB7gJvcVGhUIEw">other test</a></span><span>&nbsp;like quicksort, prime number, recursive if , and int array test.</span></p><p class="c6 c9"><span></span></p><p class="c6"><span>My program is published in github: </span><span class="c3"><a class="c11" href="https://www.google.com/url?q=https://github.com/jiady/compiler-llvm&amp;sa=D&amp;ust=1453306343847000&amp;usg=AFQjCNFfRMW_HN8R8odg-JAf8SLY1UXeTg">https://github.com/jiady/compiler-llvm</a></span><span>. Feel free to download, comment or modify it.</span></p><p class="c6 c9"><span></span></p><p class="c6"><span>You can see the commit history here: </span><span class="c3"><a class="c11" href="https://www.google.com/url?q=https://github.com/jiady/compiler-llvm/commits?author%3Djiady&amp;sa=D&amp;ust=1453306343848000&amp;usg=AFQjCNFudcD8IZ_pBDv3sOtjWv4vBnU-Mw">https://github.com/jiady/compiler-llvm/commits?author=jiady</a></span></p><h2 class="c6 c22"><a id="h.xorknc3lgh5" name="h.xorknc3lgh5"></a><span>Philosophy</span></h2><h3 class="c6 c22"><a id="h.219du5jucgq0" name="h.219du5jucgq0"></a><span>Programing for debug</span></h3><p class="c6"><span>At the very begining I realize that this is such a big project that without a great debug method it will be very hard for me to make it. I have majorly two way on this.</span></p><ol class="c33 lst-kix_stvb7tzzd7w-0 start" start="1"><li class="c5"><span>I make plenty of log and comment in generated llvm code to make sure every move is correct. Every generated code is along with a comment that indicate structure infomation of the parse tree. And I can easily see the parents of that node and so on.</span></li><li class="c5"><span>I check the assumptions before doing any logic, for example I will check if this node&rsquo;s number is correct, if the content is valid. I check like content==&rdquo;STMTBLOCK: XXXXX&rdquo; instead of content.at(0)==&rsquo;S&rsquo;. What I want to do is to make every move clear. I will check if I can&rsquo;t find a valid symbol or some symbol is duplicate. I will exit immediately &nbsp;instead of letting the program running on errors.</span></li></ol><h3 class="c6 c22"><a id="h.expl621idua0" name="h.expl621idua0"></a><span>Avoid duplication</span></h3><p class="c6"><span>It is common that some logic may need to be changed against the design during coding. And it will be painful if you write the same logic code for hundrends of times. When you need to change it , you will find it is impossible.</span></p><ol class="c33 lst-kix_ncdzgknfaotx-0 start" start="1"><li class="c5"><span>I use a lot of #define and helper funtion to avoid duplication.</span></li><li class="c5"><span>Why polymorphism? why not simple if else to decide calling which funtion to generate code. The quesiton should be asked as why the same infomation need to be given twice? The tree structure is given in the syntax tree already, why should you use if else to judge it again? So polymorphism is used to avoid duplication and make it more elegant.</span></li></ol><p class="c6 c9"><span></span></p><h3 class="c6 c22"><a id="h.cqaspqgr4ym0" name="h.cqaspqgr4ym0"></a><span>Design before you start coding</span></h3><p class="c6"><span>If you do not have a big picture(design) and start coding, believe it or not, you are writing shit.</span></p><h1 class="c6 c22"><a id="h.caws36ed4xjf" name="h.caws36ed4xjf"></a><span>Reference</span></h1><p class="c6"><span class="c3"><a class="c11" href="https://www.google.com/url?q=http://www.cs.sjtu.edu.cn/~jiangli/teaching/CS308/projects/LexIntroduction.pdf&amp;sa=D&amp;ust=1453306343851000&amp;usg=AFQjCNHyXjkyZCviqi-j87ZmNSm1bl0T8A">http://www.cs.sjtu.edu.cn/~jiangli/teaching/CS308/projects/LexIntroduction.pdf</a></span></p><p class="c6"><span class="c3"><a class="c11" href="https://www.google.com/url?q=http://www.cs.sjtu.edu.cn/~jiangli/teaching/CS308/projects/SetupEnvironment.pdf&amp;sa=D&amp;ust=1453306343852000&amp;usg=AFQjCNEEhXuUPb-Fd_FTiudeotPevqvZNw">http://www.cs.sjtu.edu.cn/~jiangli/teaching/CS308/projects/SetupEnvironment.pdf</a></span></p><p class="c6"><span class="c3"><a class="c11" href="https://www.google.com/url?q=http://www.cs.sjtu.edu.cn/~jiangli/teaching/CS308/projects/YaccIntroduction.pdf&amp;sa=D&amp;ust=1453306343853000&amp;usg=AFQjCNEGTrIP9uFGstEEa5xofMoA9NYuIg">http://www.cs.sjtu.edu.cn/~jiangli/teaching/CS308/projects/YaccIntroduction.pdf</a></span></p><p class="c6"><span class="c3"><a class="c11" href="https://www.google.com/url?q=http://www.cs.sjtu.edu.cn/~jiangli/teaching/CS308/projects/project2.pdf&amp;sa=D&amp;ust=1453306343853000&amp;usg=AFQjCNHRbSZVofKgXIiTZXvvXcOWyVrw7w">http://www.cs.sjtu.edu.cn/~jiangli/teaching/CS308/projects/project2.pdf</a></span></p><p class="c6"><span class="c3"><a class="c11" href="https://www.google.com/url?q=http://www.cs.sjtu.edu.cn/~jiangli/teaching/CS308/projects/project1.pdf&amp;sa=D&amp;ust=1453306343854000&amp;usg=AFQjCNHE_1Llz1TtmZdmxzTAsO2qbKBfHA">http://www.cs.sjtu.edu.cn/~jiangli/teaching/CS308/projects/project1.pdf</a></span></p><p class="c6"><span class="c3"><a class="c11" href="https://www.google.com/url?q=http://www.cs.sjtu.edu.cn/~jiangli/teaching/CS308/projects/LLVMIntroduction.pdf&amp;sa=D&amp;ust=1453306343855000&amp;usg=AFQjCNG57N_OLt-vRBEuuD-j7_U8XbKMfA">http://www.cs.sjtu.edu.cn/~jiangli/teaching/CS308/projects/LLVMIntroduction.pdf</a></span></p><p class="c6"><span class="c3"><a class="c11" href="https://www.google.com/url?q=http://www.cs.sjtu.edu.cn/~jiangli/teaching/CS308/projects/ProjectIntroduction.pdf&amp;sa=D&amp;ust=1453306343855000&amp;usg=AFQjCNEgyoLM5xFAv9yWGT0au296D4-4RA">http://www.cs.sjtu.edu.cn/~jiangli/teaching/CS308/projects/ProjectIntroduction.pdf</a></span></p><p class="c6"><span class="c3"><a class="c11" href="https://www.google.com/url?q=https://github.com/BinaryMelody/Compiler_Principle&amp;sa=D&amp;ust=1453306343856000&amp;usg=AFQjCNFehBkhEetEJqS-pNfmdvdt2Rbz-w">https://github.com/BinaryMelody/Compiler_Principle</a></span></p><p class="c6"><span class="c3"><a class="c11" href="https://www.google.com/url?q=https://github.com/vendisky/Compiler-Principles-Project-2&amp;sa=D&amp;ust=1453306343857000&amp;usg=AFQjCNEsyZGfwS0ft9Qy_8clJ5vEWxN4YQ">https://github.com/vendisky/Compiler-Principles-Project-2</a></span></p><p class="c6"><span class="c3"><a class="c11" href="https://www.google.com/url?q=https://github.com/linzebing/compiler&amp;sa=D&amp;ust=1453306343857000&amp;usg=AFQjCNGqPhR_YBFqSZ_49jjfLrL07hALxg">https://github.com/linzebing/compiler</a></span></p><p class="c6"><span class="c3"><a class="c11" href="https://www.google.com/url?q=http://llvm.org/docs/LangRef.html&amp;sa=D&amp;ust=1453306343858000&amp;usg=AFQjCNHXrtnRn6BiIumg1tGLHCPlR-gmEw">http://llvm.org/docs/LangRef.html</a></span></p><p class="c6 c9"><span></span></p><p class="c6 c9"><span></span></p><p class="c6 c9"><span></span></p><div><p class="c6 c29"><span>/</span></p></div></body></html>
